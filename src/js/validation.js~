/*
import { validationSettings, defaultErrorMessages } from './constants.js';

// Strict pattern for names - only letters, spaces and hyphens
const namePattern = /^[\p{L}\s-]+$/u;

// Helper functions
function showInputError(form, input, errorMessage, settings) {
    const errorElement = form.querySelector(`.${input.id}-error`);
    input.classList.add(settings.inputErrorClass);
    errorElement.textContent = errorMessage;
    errorElement.classList.add(settings.errorClass);
}

function hideInputError(form, input, settings) {
    const errorElement = form.querySelector(`.${input.id}-error`);
    input.classList.remove(settings.inputErrorClass);
    errorElement.textContent = '';
    errorElement.classList.remove(settings.errorClass);
}

function getErrorMessage(input) {
    if (input.validity.valueMissing) {
        return defaultErrorMessages.required;
    }
    if (input.validity.tooShort) {
        return defaultErrorMessages.minLength(input.minLength, input.value.length);
    }
    if (input.validity.tooLong) {
        return defaultErrorMessages.maxLength(input.maxLength, input.value.length);
    }
    if (input.hasAttribute('data-name-pattern') && !namePattern.test(input.value)) {
        return defaultErrorMessages.patternMismatch;
    }
    if (input.validity.typeMismatch && input.type === 'url') {
        return defaultErrorMessages.urlMismatch;
    }
    return input.validationMessage;
}

export function enableValidation(settings = validationSettings) {
    const forms = Array.from(document.querySelectorAll(settings.formSelector));
    forms.forEach(form => {
        setupFormValidation(form, settings);
    });
}

function setupFormValidation(form, settings) {
    const inputs = Array.from(form.querySelectorAll(settings.inputSelector));
    const button = form.querySelector(settings.submitButtonSelector);

    function toggleButtonState() {
        const isValid = inputs.every(input => {
            const patternValid = input.hasAttribute('data-name-pattern')
                ? namePattern.test(input.value)
                : true;
            return input.validity.valid && patternValid;
        });
        button.disabled = !isValid;
        button.classList.toggle(settings.inactiveButtonClass, !isValid);
    }

    function checkInputValidity(input) {
        let isValid = input.validity.valid;

        // Additional pattern validation for name fields
        if (input.hasAttribute('data-name-pattern')) {
            isValid = isValid && namePattern.test(input.value);
        }

        if (!isValid) {
            showInputError(form, input, getErrorMessage(input), settings);
        } else {
            hideInputError(form, input, settings);
        }
    }

    inputs.forEach(input => {
        // Add pattern validation attribute if it's a name field
        if (input.classList.contains('popup__input_type_name') ||
            input.classList.contains('popup__input_type_description')) {
            input.setAttribute('data-name-pattern', 'true');
        }

        input.addEventListener('input', () => {
            checkInputValidity(input);
            toggleButtonState();
        });

        input.addEventListener('blur', () => {
            checkInputValidity(input);
        });
    });

    form.addEventListener('reset', () => {
        inputs.forEach(input => hideInputError(form, input, settings));
        toggleButtonState();
    });

    toggleButtonState();
}

export function clearValidation(form, settings = validationSettings) {
    const inputs = Array.from(form.querySelectorAll(settings.inputSelector));
    const button = form.querySelector(settings.submitButtonSelector);

    inputs.forEach(input => {
        hideInputError(form, input, settings);
        input.setCustomValidity('');
    });

    button.disabled = true;
    button.classList.add(settings.inactiveButtonClass);
}*/


// validation.js
export const validationSettings = {
    formSelector: '.popup__form',
    inputSelector: '.popup__input',
    submitButtonSelector: '.popup__button',
    inactiveButtonClass: 'popup__button_disabled',
    inputErrorClass: 'popup__input_type_error',
    errorClass: 'popup__error_visible'
};

export const defaultErrorMessages = {
    required: 'Это обязательное поле',
    minLength: (min, current) => `Минимальная длина - ${min} символа, сейчас ${current}`,
    maxLength: (max, current) => `Максимальная длина - ${max} символа, сейчас ${current}`,
    patternMismatch: 'Разрешены только латинские, кириллические буквы, знаки дефиса и пробелы',
    urlMismatch: 'Введите URL-адрес начинающийся с http:// или https://'
};

const namePattern = /^[\p{L}\s-]+$/u;

function showInputError(form, input, errorMessage, settings) {
    const errorElement = form.querySelector(`.${input.id}-error`);
    input.classList.add(settings.inputErrorClass);
    errorElement.textContent = errorMessage;
    errorElement.classList.add(settings.errorClass);
}

function hideInputError(form, input, settings) {
    const errorElement = form.querySelector(`.${input.id}-error`);
    input.classList.remove(settings.inputErrorClass);
    errorElement.textContent = '';
    errorElement.classList.remove(settings.errorClass);
}

// Returns appropriate error message based on validation state
function getErrorMessage(input) {
    if (input.validity.valueMissing) {
        return input.dataset.errorRequired || defaultErrorMessages.required;
    }
    if (input.validity.tooShort) {
        return defaultErrorMessages.minLength(input.minLength, input.value.length);
    }
    if (input.validity.tooLong) {
        return defaultErrorMessages.maxLength(input.maxLength, input.value.length);
    }
    if (input.hasAttribute('data-name-pattern') && !namePattern.test(input.value)) {
        return input.dataset.errorPattern || defaultErrorMessages.patternMismatch;
    }
    if (input.validity.typeMismatch && input.type === 'url') {
        return input.dataset.errorUrl || defaultErrorMessages.urlMismatch;
    }
    return input.validationMessage;
}

// Checks if input is valid and shows/hides error message accordingly
function checkInputValidity(form, input, settings) {
    let isValid = input.validity.valid;

    // Additional pattern validation for name fields
    if (input.hasAttribute('data-name-pattern')) {
        isValid = isValid && namePattern.test(input.value);
    }

    if (!isValid) {
        showInputError(form, input, getErrorMessage(input), settings);
    } else {
        hideInputError(form, input, settings);
    }
}

// Toggles submit button state based on form validity
function toggleButtonState(form, inputs, button, settings) {
    const isValid = inputs.every(input => {
        const patternValid = input.hasAttribute('data-name-pattern')
            ? namePattern.test(input.value)
            : true;
        return input.validity.valid && patternValid;
    });
    button.disabled = !isValid;
    button.classList.toggle(settings.inactiveButtonClass, !isValid);
}

// Sets up event listeners for form validation
function setupFormValidation(form, settings) {
    const inputs = Array.from(form.querySelectorAll(settings.inputSelector));
    const button = form.querySelector(settings.submitButtonSelector);

    // Set custom error messages in data attributes for name fields
    inputs.forEach(input => {
        if (input.classList.contains('popup__input_type_name') ||
            input.classList.contains('popup__input_type_description') ||
            input.classList.contains('popup__input_type_card-name')) {
            input.setAttribute('data-name-pattern', 'true');
            input.dataset.errorPattern = defaultErrorMessages.patternMismatch;
        }
    });

    // Validate on input and blur events
    inputs.forEach(input => {
        input.addEventListener('input', () => {
            checkInputValidity(form, input, settings);
            toggleButtonState(form, inputs, button, settings);
        });

        input.addEventListener('blur', () => {
            checkInputValidity(form, input, settings);
        });
    });

    // Reset form validation on form reset
    form.addEventListener('reset', () => {
        inputs.forEach(input => hideInputError(form, input, settings));
        toggleButtonState(form, inputs, button, settings);
    });

    // Initial button state
    toggleButtonState(form, inputs, button, settings);
}

// Enables validation for all forms with given settings
export function enableValidation(settings = validationSettings) {
    const forms = Array.from(document.querySelectorAll(settings.formSelector));
    forms.forEach(form => {
        setupFormValidation(form, settings);
    });
}

// Clears validation errors and resets form
export function clearValidation(form, settings = validationSettings) {
    const inputs = Array.from(form.querySelectorAll(settings.inputSelector));
    const button = form.querySelector(settings.submitButtonSelector);

    inputs.forEach(input => {
        hideInputError(form, input, settings);
        input.setCustomValidity('');
    });

    button.disabled = true;
    button.classList.add(settings.inactiveButtonClass);
}